<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Check-In Funnel</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #controls { margin-bottom: 15px; }
    #dateSlider { width: 100%; max-width: 600px; }
    button { margin: 0 5px; padding: 5px 10px; }
    svg { overflow: visible; }
    .bar-segment { stroke: #fff; }
    .label-total { font-size: 12px; fill: #fff; text-anchor: middle; font-weight: bold; }
    .step-pct-label { font-size: 12px; fill: #333; text-anchor: start; }
    .y-label { font-size: 12px; text-anchor: end; }
  </style>
</head>
<body style="background-color: #f4f3e9;">
  <div id="controls">
    <button id="prevDay">← Prev</button>
    <label>Event Date: <span id="selectedDate"></span></label>
    <button id="nextDay">Next →</button>
    <br />
    <input type="range" id="dateSlider" />
  </div>

  <svg id="funnelChart" width="1500" height="400"></svg>
  <div id="funnelSummary" style="
    position: absolute;
    top: 200px;     
    right: 100px;   
    width: 300px;   
    font-size: 14px;
    line-height: 1.4;
  ">
  </div>
  <script>
    const stepLabels = {
      'CHECKIN_ELIGIBLE':           'Check-In Eligible',
      'CHECKIN_INITIATED':          'Check-In Initiated',
      'CHECKIN_IDENTIFICATION':     'Identity Verification',
      'CHECKIN_PAYMENT':            'Payments',
      'CHECKIN_SUCCESS':            'Check-In Success'
    };


    const funnelOrder = [
      'CHECKIN_ELIGIBLE',
      'CHECKIN_INITIATED',
      'CHECKIN_IDENTIFICATION',
      'CHECKIN_PAYMENT',
      'CHECKIN_SUCCESS'
    ];

    const outcomeMap = {
      'WMA_CHECKIN_ID_VERIFICATION_COMPLETE': 'Completed',
      'WMA_CHECKIN_PAYMENT_SUCCESS': 'Completed',
      'WMA_CHECKIN_ROOM_ASSIGNMENT_COMPLETE': 'Completed',
      'WMA_IDME_PHONE_VERIFICATION_INITIATED': 'Started',
      'WMA_IDME_DOC_VERIFICATION_INITIATED': 'Started',
      undefined: 'Completed',
      '':       'Completed',
      'WMA_CHECKIN_PAYMENT_FAILED': 'Resolvable Issue',
      'WMA_CHECKIN_ROOM_ASSIGNMENT_FAILED': 'Resolvable Issue',
      'WMA_ROOM_ASSIGNEMENT_POPUP_CANCEL': 'Resolvable Issue',
      'WMA_ID_NAME_MATCHING_FAILED': 'Failed',
      'WMA_CHECKIN_PAYMENT_FAILED_MAX_ATTEMPTS': 'Failed',
      'CHECKIN_INELIGIBLE': 'Check-In Ineligible'
    };
    const colorScale = d3.scaleOrdinal()
      .domain(['Completed','Started','Resolvable Issue','Failed', 'Check-In Ineligible'])
      .range([ '#4B2E1E', '#999999', '#FFD54F', '#D32F2F', '#D32F2F' ]);

    const svg = d3.select('#funnelChart');
    const margin = { top: 40, right: 200, bottom: 30, left: 200 };
    const width = +svg.attr('width') - margin.left - margin.right;
    const height = +svg.attr('height') - margin.top - margin.bottom;
    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleLinear().range([0, width]);
    const yScale = d3.scaleBand().domain(funnelOrder).range([0, height]).padding(0.2);

    g.append('g').attr('class', 'x-axis');
    const labelG = g.append('g').attr('class', 'y-axis-labels');

    d3.csv('data.csv', d => ({
      step: d.STEP,
      category: outcomeMap[d.STEP_OUTCOME] || 'Started',
      date: new Date(d.EVENTDATE),
      user: d.RESVNAMESOURCEID
    })).then(data => {
      const dates = Array.from(new Set(data.map(d => +d.date)))
        .map(ts => new Date(ts)).sort((a,b) => a - b);

      const slider = d3.select('#dateSlider')
        .attr('min', 0).attr('max', dates.length - 1).attr('step', 1).attr('value', dates.length - 1)
        .on('input', function() { updateChart(dates[+this.value]); });

      d3.select('#prevDay').on('click', () => {
        let i = +slider.property('value'); if (i>0) slider.property('value', --i).dispatch('input');
      });
      d3.select('#nextDay').on('click', () => {
        let i = +slider.property('value'); if (i<dates.length-1) slider.property('value', ++i).dispatch('input');
      });

      d3.select('#selectedDate').text(d3.timeFormat('%Y-%m-%d')(dates[dates.length-1]));
      updateChart(dates[dates.length-1]);

      function updateChart(selectedDate) {
        d3.select('#selectedDate').text(d3.timeFormat('%Y-%m-%d')(selectedDate));

        const dayData = data.filter(d => +d.date === +selectedDate);
        const nested = Array.from(
          d3.rollup(
            dayData,
            v => new Set(v.map(d => d.user)).size,
            d => d.step,
            d => d.category
          ),
          ([step, cats]) => {
            const outcomes = Array.from(cats.entries()).map(([key, count]) => ({ key, count }));
            const total = d3.sum(outcomes, o => o.count);
            return { step, outcomes, total };
          }
        )
        .filter(d => funnelOrder.includes(d.step))
        .sort((a,b) => funnelOrder.indexOf(a.step) - funnelOrder.indexOf(b.step));

        const initiator = nested.find(d => d.step === 'CHECKIN_INITIATED');
        const initiatorTotal = initiator ? initiator.total : 0;

        const maxTotal = d3.max(nested, d => d.total) || 0;
        xScale.domain([0, maxTotal]);
        // g.select('.x-axis')
        //   .attr('transform', `translate(0,0)`)
        //   .call(d3.axisTop(xScale).ticks(5));

        // Step Counts
        labelG.selectAll('text.count-label')
          .data(nested, d => d.step)
          .join('text')
            .attr('class','count-label')
            .attr('font-size','12px')
            .attr('text-anchor','end')
            .attr('x', -30) 
            .attr('y', d => yScale(d.step) + yScale.bandwidth()/2 + 4)
            .text(d => d.total);

        // Step names
        labelG.selectAll('text.y-label')
          .data(nested, d => d.step)
          .join('text')
            .attr('class','y-label')
            .attr('font-size','12px')
            .attr('text-anchor','end')
            .attr('x', -80) 
            .attr('y', d => yScale(d.step) + yScale.bandwidth()/2 + 4)
            .text(d => {
              if (d.step==='CHECKIN_ELIGIBLE' && selectedDate < new Date('2025-05-26'))
                return '';
              return stepLabels[d.step] || d.step.replace(/_/g,' ');
            });


        const steps = g.selectAll('.step-group').data(nested, d => d.step);
        const enter = steps.enter().append('g').attr('class', 'step-group');
        steps.exit().remove();
        const merge = enter.merge(steps)
          .transition().duration(200)
          .attr('transform', d => {
            const w = xScale(d.total);
            return `translate(${(width-w)/2},${yScale(d.step)})`;
          });

        merge.each(function(d) {
          // ordering sub outcomes
          const categoryOrder = ['Completed','Started','Resolvable Issue','Failed','Check-In Ineligible'];
          d.outcomes.sort((a,b) =>
            categoryOrder.indexOf(a.key) - categoryOrder.indexOf(b.key)
          );
          const bar = d3.select(this);
          let cum = 0;
          const seg = bar.selectAll('.bar-segment').data(d.outcomes, o=>o.key);
          seg.enter().append('rect').attr('class','bar-segment')
            .attr('y',0).attr('height',yScale.bandwidth())
            .merge(seg)
            .transition().duration(200)
            .attr('x', o=>{ const x=cum; cum+=o.count; return xScale(x); })
            .attr('width', o=>xScale(o.count))
            .attr('fill', o=>colorScale(o.key));
          seg.exit().remove();

          const totalW = xScale(d.total);

          if (d.step !== 'CHECKIN_INITIATED' && initiatorTotal > 0) {
            const pct = Math.round(d.total / initiatorTotal * 100);
            bar.selectAll('.label-inner-pct').data([d])
              .join('text')
                .attr('class','label-inner-pct')
                .attr('font-size','12px')
                .attr('fill','#fff')
                .attr('text-anchor','middle')
                .attr('x', totalW / 2)
                .attr('y', yScale.bandwidth() / 2 + 4)
                .text(`${pct}% of Check-In Initiated`);
          }
        });

      const prevData = nested.slice(1);  // everything except the first step
        g.selectAll('text.step-pct-label')
          .data(prevData, d => d.step)
          .join(
            enter => enter.append('text')
                          .attr('class','step-pct-label'),
            update => update,
            exit  => exit.remove()
          )
          .attr('font-size','10px')
          .attr('fill','#333')
          .transition().duration(200)
          .attr('x', width + 50)
          .attr('y', d => yScale(d.step) + yScale.bandwidth()/2 + 10)
          .text((d,i) => {
            const prevTot = nested[i].total;    // previous step total
            return prevTot > 0
              ? `${Math.round(d.total / prevTot * 100)}% of previous step`
              : '';
          });

          // summary
          let html = '<h3>Funnel Summary</h3>';
          nested.forEach(d => {
            const name = stepLabels[d.step] || d.step.replace(/_/g,' ');
            html += `<div><strong>${name} Step:</strong> ${d.total}</div>`;

            // nested items per step
            if (d.outcomes.length > 1) {
              html += '<ul style="margin:4px 0 8px 16px;padding:0;">';
              d.outcomes.forEach(o => {
                html += `<li>${o.key}: ${o.count}</li>`;
              });
              html += '</ul>';
            }
          });

          d3.select('#funnelSummary').html(html);
      }

      // Random change
    });
  </script>
</body>
</html>
